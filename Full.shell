---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------				
			-- Programação Shell Script - Automatizando Rotinas no Linux --
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
Prof: Ricardo Prudenciato

-----------------------
- Seção 1: Introdução -
-----------------------

1.o que é Shell Script

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
2.Como será o Curso

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
3.Antes de começarmos

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
4.Arquivos e Scripts Usados Durante o Curso


---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	


Administrador de sistemas e analista de suporte.

Para quem deseja trabalhar com Linux e Unix

Unix  --> S.O
Linux --> S.O (Linux é baseado no Unix.)
 
 
Shell --> É a interface entre o usuário e o sistema operacional (kernel)

Kernel --> O kernel é considerado o principal item dos sistemas operacionais, 
		   sendo que ele é a ligação entre o processamento de dados e os programas.
		   

Verificar se o vi está instalado: (Vi editor de testo do linux)
sudo dpkg -l |grep vim 


Se não tiver o vi Instalado, instale com o comando abaixo:
sudo apt-get install vim

Usuario: adriano
Senha: Adri@no310710


---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
Prof: Ricardo Prudenciato

-----------------------
- Seção 2:  -
-----------------------

5.O Shell

  É a interface entre o usuário e o sistema OP. Unix/Linux
  
  USUÁRIO
	SHELL --> Uma das ferramentas para acessar o Kernel é o Shell.
		KERNELL --> Administrador do Hardware
			HARDWARE --> Baixo nível, CPU, memório, HD e etc.



 TIPOS DE SHELL:
 ---------------
 
 Bourne Shell (sh): Shell original e padrão do Unix
 
 Bourne-Again Shell (bash): Shell padrão no Linux compatível com sh mas com melhorias.
							Tbm incorpora recursos so csh e Ksh.

 Korn Shell (Ksh): Tbm uma melhoria do bourne shell 

 C Shell (csh): Traz para o shel recursos da linguagem C.

 
 
 Qual o shell estou usando --> echo $0
 Outra forma de verificar --> tail /etc/passwd
 
 Verificar se outros shel estao instalado na minha maquina: --> sudo -l |grep ksh
 
 Se eu quisesse instalar --> sudo apt-get install ksh
 
 Entrar no Shell ksh --> ksh
 Verificando novamente -->  echo $0
 Para sair do shel ksh --> exit
 
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
6.Principais Comandos Linux - Parte 1

 nome do comando --help --> mostra as opções q o comando oferece ex:
 touch --help 
 man touch --> Mostra o manual mais completo
 
 
 cd arquivos --> Entrar em um diretorio 
 cd .. --> volta para o diretorio anterior
 
 cd../../ --> Volta para a raiz
 
 cd - --> volta p/ o arquivo anteiror
 
 cd  --> cd espaco vai para o home
 
 pwd --> mostra o diretorio atual
 
  
 cd ~usuario --> vai p/ o home do usuario q eu quiser
 
 ls --> listar
 
 ls -ltr --> ordena do mais velho para o mais novo
 
 ls -l --> mostra os detalhes dos diretorios
 
 
 ps --> mostra meus processos do meu usuario apenas na minha sessao
 
 ps axu --> Mostra varias informaçoes: Nome do usuario dono do processo. 
			id do processo. Consumo de CPU/Memoria. 
			Quanto tempo esta em execucao e o nome do processo.
 
 touch --> P/ criar um arquivo em branco, ou atualizar um arquivo q ja existe			
		   Para criar --> touch arquivo-teste
		   
 touch --help --> Para ver as opcoes dos comandos			


 echo --> Para mostrar na tela algum parametro q vc deu ex:
 echo Adriano estudando shell script
 echo -n Adriano estudando shell script --> -n não vai quebrar a linha
 echo -e "Curso shell\n script" -- Coloca uma quebra de linha 
 
 echo -e --> Aceita caracteres especiais ex:
  echo -e "Curso shell\script\novo desafio" 
 
 mkdir --> criar um diretorio ex:
 mkdir diretorio1
 
 Criar um diretorio dentro de um determinado diretorio:
 mkdir diretorio1/exercicio1
 
 rm xxxxx --> Comando para remover/apagar um arquivo
 
 rm -r xxxxx --> Comando para remover/apagar um diretorio
 
 rm Aula* --> (Apaga tudo q começa com Aula) Cuidado!
 
 rmdir xxxx --> Só funciona se o diretorio estiver vazio
 
 sleep --> Comando q conta um tempo. Ex:
 sleep 10 --> conta 10segundos e volta a linha de comando
 

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
7.Principais Comandos Linux - Parte 2

 Comandos de manipulação de arquivos:
 
  O comando e do Linux é um dos mais úteis para se aprender. 
  Seu nome é uma derivação da palavra concatenate (concatenar) e permite que você crie, 
  e exiba arquivos no formato padrão de tela ou em outro arquivo, entre outras coisas.
 
 cat arquivos.txt --> P/ exibir o conteudo de arquivo
 cat -b alunos2.txt --> Numera as linhas q nao estão em branco
 cat -n alunos2.txt --> Numera todas as linhas, até as q estão em branco
 cat -A alunos2.txt --> Mostra caracteres especiais 
						(Ajuda a identificar os caracteres q nao aparecem)

 cat --help --> Mostra todas a opções possíveis

 tac alunos2.txt --> Lê o arquivo em ordem decrescente
 
 tail arquivilongo.txt --> Mostra as ultimas dez linhas
 tail -n5 arquivilongo.txt --> Determino quantas linhas quero exibir.
 tail -5 arquivilongo.txt --> Outra forma de fazer a mesma coisa
 
 
 
 head arquivilongo.txt --> Mostra as primeiras dez linhas do arquivo
 head -5 arquivilongo.txt --> Determino quantas linhas quero exibir.
 
 head -c10 arquivilongo.txt --> Determino a qtde de caracteres q quero exibir
 
 
 
 wc --> Conta caracteres,linhas, palavras e bytes de um arquivo.
 wc alunos.txt --> A saída mostrou qtde de linhas	
								   qtde de caracteres	
								   qtde de Bytes

 wc -l alunos.txt --> Mostrará só o número de linhas								   
 wc -m alunos.txt --> Mostrará só o número de caracteres
 wc -c alunos.txt --> Mostrará só o número de bytes
 
 wc alunos* --> Faz a contagem para todos os arquivos
 
 tail -n5 alunos2.txt |wc -w --> Está pegando a saído do arquivo alunos2.txt e 
											usando como parametro de entrada.
											
 											
 sort --> Para ordenar um arquivo
 
 sort alunos.txt --> Exibe de forma ordenada
 sort -r alunos.txt --> Ordena de forma reversa(z-a)
 sort -k2 alunos.txt --> ordena a partir do segundo campo
 sort -k3 alunos.txt --> ordena a partir do terceiro campo
 
 uniq alunos.txt --> Toda vez q um nome estiver repitido na sequencia, mostrará apenas um.
  
  Uma forma de resolver isso, é ordenar primeiro e depos exibir com o uniq. Exemplo:  
 sort alunos.txt |uniq
 
 --Primeiro ordeno depois exibe, exemplos abaixo:
 
 sort uniq -u alunos.txt --> Mostra apena os q apareceram uma vez
 sort uniq -d alunos.txt --> Mostra apena os q apareceram duplicados
 sort uniq -c alunos.txt --> Conta as repetições
 
 sort alunos.txt |uniq -c |sort --> Conta os q repitiram mais vez e ordena do maior p/ menor
 
 sort alunos.txt |uniq -c |sort -r |head -n1 --> Só a linha que tem mais repetição
 
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
8.Principais Comandos Linux - Parte 3

 
 tr --> Muda traduz e deleta caracteres(Pode ser uma linha ou um arquivo):
 
 cat alunos.txt |tr a e --> (Trocou toda letra a por e)
 
 cat alunos.txt |tr a-z A-Z --> (Trocou caixa baixa por caixa alta)
 
 cat alunos.txt |tr aei AEI --> (Toda letra aei foi trocada por AEI)
 
 cat alunos2.txt |tr ' ' '\t' --> (Trocando o espaço por tab)
 
 cat alunos2.txt |tr ' ' '\t' | cat -A --> (Consigo ver melhor os tab do arquivo acima)
 
 cat alunos2.txt |tr -d aei --> (Toda vez q aparecer as letras aei será deletado)
 
 echo "Curso Shell Script" |tr l L --> (Toda vez q encontrar um l trocará por L)
 
 echo "Curso Shellllllll Script" |tr -s 'l' --> (Vai comprimir o l) Exemplo: Shell p/ Shel
 
 tr --help --> (Mostra varias forma de usar esse comando)
 
 echo Curso Shell Script |tr [:lower:] [:upper:] --> (Transformar tudo de minusculo p/maiusculo)
 

 cut --> Comando para cortar uma string

 cat alunos2.txt |cut -c1-5  --> (Cortará do caracter 1-5 de cada linha)
 
 cat alunos2.txt |cut -c1,2,3--> (Quero cortar do caracter um, dois e cinco)
 
 cat alunos2.txt | cut -c5- --> (Quero cortar a partir do caracter 5 p/ frente)
 
 cat alunos2.txt | cut -c-5 --> (Cortar até o caracter 5)
 
 cat alunos2.txt | cut -f1 --> (f1 eu mostro apenas o campo 1)
 
 cat alunos2.txt |cut -d " " -f2- --> (Mostrar do campo 1 ao 3 separando com espaço) // d sig. delimitador
 
 tail /etc/passwd | -d":" -f1,5 --> (mostrar o campo 1 e o 5 separados por :)
 
 
 diff --> Usado para separar dois arquivos. (Sign. Diferença)
 
 diff alunos2.txt alunos3.txt --> (Exibe apenas a diferença entre os arquivos)
 diff alunos2.txt alunos3.txt | cat -A --> (A mesma coisa, porém, mostrou q tem um espaço)
 
 diff -w alunos2.txt alunos3.txt --> (Compara os dois arquivos, porém, 
										desconsidera os espaços em branco)
										
 Usando o comando "diff" para comparar diretórios:
 -------------------------------------------------
 
 diff -r arquivos arquivos-copia --> (Compara os dois arquivos)
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
9.Principais Comandos Linux - Parte 4
 
 
 Comando "grep" Serve para procurar o conteúdo dentro de uma string:
 -------------------------------------------------------------------
 
 grep Claudia alunos2.txt --> (Retornar toda vez q aparecer o nome Claudia)
 
 grep Claudia alunos* --> (Procura em todos os arquivos alunos q contenham a palavra Claudia)
 
 grep "Ricardo prudenciato" alunos*
 
 
 Quais as opções do comando "grep"?
 ----------------------------------
 
 grep -i RICARDO alunos*  --> (Tira a opção do case sensitive, ou seja independente de ser 
								caixa alta ou baixa) (-i deixa o comando mais pesado)
								
 grep -c Ana alunos2.txt --> (Vai contar quantas vezes encontrou a palavra Ana)								
 grep -c Ana alunos.txt* 
 
 grep -v Ana alunos.txt* --> (Faz ao contrario, não vai mostrar a linha q contenha essa 
								palavra)
 
 grep -r Ana* --> (Procurar todos os arquivos desse diretório com a palavra ana) 
 grep -rl Ana* --> (Só mostra os arquivos q contenham essa palavra, mas não lista) 
 
 cat alunos2.txt |grep Rafael 
 
 grep -A3 Carlos alunos2.txt --> (A sig. After, ou seja, 3 linhas depois da ocorrencia da palavra Carlos)
  //Muito usado para analisar log
  
  grep -B3 Carlos alunos2.txt --> (A sig. Before, ou seja, 3 linhas antes da ocorrencia da palavra Carlos)
  //Muito usado para analisar log
  
  
  Tem três opções: 
  grep  --> Para procurar o conteúdo dentro de uma string (Aceita expressão regular simples)
  fgrep --> Para procurar o conteúdo dentro de uma string (Não aceita expressões regulares)
  egrep --> Para procurar o conteúdo dentro de uma string (Aceita expressão regular estendidas)
    
 
 Comando "sed" faz um filtro e substituição de conteúdo:
 -------------------------------------------------------
 
 sed --help --> Para mostrar as posibilidades de comando
 
 sed '1,3 d' alunos2.txt --> (Para deletar da linha 1 a linha3) 
 sed  /Rafael/d alunos2.txt  --> (Procurando Rafael e deletando a linha inteira 
									toda vez q encontrar)
									
 cat alunos2.txt |sed 's/Paulo/Joao/'--> (P/ substituir o Paulo pelo Joao)									
 
 
 echo "Curso Linux Shell Script Linux" |sed 's/Linux/Unix'
									--> (Substituindo a primeira ocorrencia Linux por Unix)
										 Exemp: Curso Unix Shell Script Linux 								 

 echo "Curso Linux Shell Script Linux" |sed 's/Linux/Unix/g' 
										--> (Para substituir todas as ocorrencias tem q usar g)
										 Exemp: Curso Unix Shell Script Unix 
										 
    
 echo "Curso Linux Shell Script Linux" |sed 's/ //g' 
										--> (Toda vez q encontrar um espaço troco por nada)										 
										Exemp: CursoLinuxShellScriptLinux

 
 Comando "More"	exibe paginando, mostra o q tem na primeira página e vai descendo:									
 ---------------------------------------------------------------------------------
 
 more arquivolongo.txt
 
 less arquivolongo.txt --> (A mesma coisa do more, porém, tras mais possibilidades)
 
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
10.Principais Comandos Linux - Parte 5
 
 find --> Serve para procurar por diretorios,arquivos
 
 find /home  
 find /  
 find ./     --> Do meu diretorio pra frente
 
 find ./ -name alunos.txt --> Procura arquivos 
 find ./ -name alunos.txt* --> Procura arquivos 
 find ./ -name *copia*
 find ./ -user adr -name alunos2.txt
 										
 find ./ -name alunos* -exec ls -l {} \. --> (no lugar do {} sera colocado as saidas do comando)
 
 date --> (Mostra a data e hora do sistema. Sem parametros)
 date --help --> (Mostra todas as possibilidade)
 
 date +%H 	 --> (Se eu quiser mostrar só a hora?)
 date +%M 	 --> (M maiusculo para minuto)
 date +%m 	 --> (m minusculo para mês)
 date +%D 	 --> (D Mostra a data no seguinte formato: 06/23/20)
 date +%d 	 --> (m minusculo só o dia)
 date +%d/%m --> (para dia e mes)
 
 
 seq Comando para gerar uma sequencia:
 -------------------------------------
 
 seq 10   	--> (Faz uma seq de 1 a 10)
 seq 0 12 	--> (vai do 0 ao 12)
 seq 5 a2 	--> (vai do 5 ao 12)
 seq 5 2 30 --> (vai do 5 ao 30 com intervalos de dois em dois)
   // Muito usado em instruções de loop, for, while
   
 
 expr --> Comando utilizado para fazer contas:
 ---------------------------------------------
 
 expr --help --> (Para ver todas as operações possíveis)
 
 expr 5 + 2 --> (7 a sintaxe precisa de espaço)
 
 expr 5 / 2 --> (2 n mostra as casas decimais)
 
 expr 5 /* 2 --> (10 neste caso te q usar a barra para proteger, pq no shell * 
					é um caracter especial)

 					
 
 expr 5 /* 2 - 2 --> (8) 
 
 echo 3 + 2 | bc --> (bc interpleta uma string como numerico)
 
 echo "(3 + 2)*5" | bc --> (25)
 
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
11.Execução Sequencial de Comandos do Shell

 cat alunos.txt |wc -l --> (listou o arquivo/ contou numero de linhas)
 
 date; echo Linux; ls --> (Um exemplo de sequencia de comandos)
 
 ls alunos.txt && echo Linux --> (&& Sign. q se o 1º comando falhar ele nem executa o 2º.)
									Caso não queira app essa regra, deve utilizar --> ;

 									
 ls alunos.txt || echo Linux --> (|| Sign. q se o 1º comando for executado com sucesso eu não executo o 2º.
											 se o 1º der erro, eu executo o 2º)
											 
 ls -l --> (Total de arquivos e o usuario, local e etc.)										 
 
 cd .. --> (P/ ver o diretorio anterior)
 ls    --> (P/ listar o diretorio)
 
 
 Como voltar p/ o arquivo anterior e listar em um unico comando?
 
 cd ..; ls -l --> (Conforme o exemplo acima, em um unico comando, 
					voltou p/ o diretorio anterior e listou os conteudo do arquivo)
					
 ( cd ..; ls -l ) --> Colocar entre () sign q implicitamente sera aberto um novo Shell, 
						e já volta p/ o Shell atual					
						
 						
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
12.Redirecionamento de Entrada e Saída

 Todo comando recebe um entrada e gera uma saída padrão e uma saída de erro
 
 Entrada 	   --> STDIN  (0)
 Saída Padrão  --> STDOUT (1)
 Saída de Erro --> STDERR (2)
 
 As saídas tanto STDOUT e STDERR são exibidas na tela, porém, essas saídas podem ser 
 redirecionadas p/ outro arquivo, uma impressora e etc.
 
 cat alunos3.txt --> (Exibicao do conteudo do arquivo na tela) 
 
 
 Redirecionamento de arquivos:
 
 > Criar 
 >> Existente
 
 Exemplos de redirecionamento de saídas:
 ---------------------------------------

 cat alunos3.txt > alunos-temp.txt --> (> Criando um novo arquivo)
 cat alunos3.txt >> alunos-temp.txt	-->	(>> Redirecionando p/ um novo arquivo)									 
 
 cat alunos3.txt > alunos-temp.txt
 cat alunos-temp.txt
 
 date > alunos-temp.txt --> (Pegou a saída e sobrescreveu o arquivo, ou seja, apagou o q tinha)
 
 date >> alunos-temp.txt --> (Vai concatenando as saídas, e mantendo o conteudo do arquivo anterior)
 
 ls -l alunos.txt
 
 ls -l alunos.txt5 > log.out --> (esse arquivo nao existe, portanto deve ser direcionado para a 
									saida de erro STDERR (2).) Exemplo:
 									
 
 ls -l alunos.txt5 2> log.out --> (Quando o arquivo n existe precisa ser jogado para log de erro:
									STDERR (2), conforme este exemplo)
 
  
 ls -l alunos.txt5 2>> log.out --> (2>> p/ Jogar no log de erro: STDERR (2) e concatenar as saídas)
 
 
 Usando os dois comando em uma uncia instrução:

 ls -l alunos.txt5 > log.out 2> log-erro.out --> (Se der certo, joga no 1º, se der errado joga no 2º)

 ls -l alunos.txt5 >> log.out 2>&1 --> (Saída padrão vai ser a mesma q a saida de erro) 
 
 cat log.out
 cat log-erro.out
 
 As saídas dever ser jogadas para um arquivo de log, ou para lugar nenhum --> Ex. /dev/null
 /dev/null --> Serve p/ omitir uma saída de erro, q eu não quero q apareça.
 
 Um outro exemplo de redirecionamento:

cat alunos.txt |grep adr

 
 
 Exemplos de redirecionamento de entradas:
 -----------------------------------------
 
 cat alunos.txt |tr a A 
     Obs: O comando 'tr' tem q receber uma entrada
	 
 Uma outra forma de fazer a mesma coisa:
 
 tr 'a' 'A' < alunos.txt --> (Estou redirecionando a saida do arquivo com parametro de entrada 
								p/ o comando tr)

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
13.Variáveis no Shell

 O Shell trabalha com variáveis de ambientes, variáveis setadas nele.
 Essas variáveis são carregadas no momento do login, ao iniciar a sessão e fica disponível para o 
usuário e para o sistema em geral.
 
 Essas variável são possíveis verificar por dois comandos: 
 
 env --> Vê a variável q foi exportada
 set --> Vê as variáveis locai e as exportadas
 
 env |less --> ()
 set |less --> ()

 Como referenciar essa variáveis?
 --------------------------------
 
 Sempre referenciar uma variável com o sinal de $ na frente. Exemplo:
 
 echo $HOME --> (P/ ver o conteúdo da variável HOME)
 
 
 Declarando variável no Shell:
 -----------------------------
 
 Variáveis no Shell, pode começar com letras maiuscula ou minuscula e_
 
 Exemplo:
 
 Variavel1=Adriano
 echo variavel1
 
 
 Curso="Curso de Shell Script"
 echo $Curso
 
 
 echo $$ --> (Mostra o PID da sessão atual)
				//process identifier (PID) ou ID do processo
				
 ps axu |grep bash --> (Mostra os processos q estão em execução)				
 
 
 Quando a variável é declara, ela fica local. Não é acessível a outros Bash, quando acessar de novo 
essas variáveis não estarão mais disponíveis, são apenas locais desse bash.
 Como exportar a variável?
 
 Declarando variável e atribuindo valor:
 ---------------------------------------
 
 TESTE=Curso
 echo $TESTE
 
 echo $$
  // meu PID 10643
  
  
  Para abrir um bash em cima do atual é só digitar o comando abaixo:
  
  bash
  echo $$ --> (Mostra o PID da sessão)
  // meu PID da nova sessão 10811
  exit --> (P/ Sair da sessão atual e voltar p/ a anterior)
  
  
  Exportando a variável para os processos filhos desse Bash
  
  export TESTE --> (Será exposta p/ outros processos filhos desse bash)
  
  
  
  Como colocar o resultado de um comando dentro de uma variável?
  --------------------------------------------------------------
  
  date +%H --> (Hora atual do sistema)
  
  Para guardar esse valor dentro de uma variável?
  -----------------------------------------------
  
 HORA=`date +%H´ `--> ( Não é aspas, isto é uma crase. 
						Usado p/ guardar um resultado dentro da variável)
						
 Uma outra forma é (). Exemplo:

 MINUTO=$(date +%M) --> (Guardando o resultdo na variável)
 echo $MINUTO
 
 exibindo as duas variáveis:
 
 
 echo $HORA:$MINUTO
 
  
 env --> Vê a variável q foi exportada
 set --> Vê as variáveis locai e as exportadas
 
 
 Exemplo:
 
 env |grep HORA
 set |grep HORA
 
 
 export VAR1=Valor --> (Declarando e exportando ao mesmo tempo)
 env |grep VAR1 --> (Ele reconhece essa variável)
 
 
 Em resumo essas foram as variáveis de ambiente utilizadas dentro do Shell, muito utilizadas em
Script. 

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
14.O uso das Aspas no Shell
 
 O Shell tem uma serie de caracteres especiais. 
 
 $  	--> P/ referenciar um avariável
 ' `´ ' --> P/ fazer uma execução de subcomandos
 
 Esse caracteres no momento da execução são interpretados, a primeira coisa q o Shell faz é 
interpretar os caracteres especiais.

 Tem situações que não desejamos que o Shell traduza esses caracteres.

 Usamos as aspas para proteger, fazer com q o Shell ignore esses caracteres.
 
 Exemplos:
 
 echo * --> (Isso sign. pegar todos os arquivos do diretório atual)
 echo "*" --> (Neste caso ele não interpreta o *)Isso sign. proteger o caracter com as aspas duplas
 echo '*' --> (tbm é possível proteger com aspas simples)
 echo \* --> (\ tbm protege o caracter seguinte)
 
 ls aluno*   --> (Listar toda palavra ou string que comece com a palavra aluno)
 ls "aluno*" --> (Quando eu faço isso, estou protegendo e o Shell não vai encontrar)
 
 Formar de proteger o caracter:
 ls "aluno*"
 ls 'aluno*'
 ls aluno\*
 
 As aspas duplas protegem todos os caracteres exceto --> $ ´ /
 As aspas simples protegem tudo
 
 Exemplo:
 
 echo "$TESTE" --> (O shell continua interpretando)
 echo '$TESTE' --> (Neste caso, não funciona, pq o Shell protege)
 echo \$TESTE  --> (tbm não funciona, o Shell protege)
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
15.O editor VI

 Alguns editores de texo:
 
 gedit
 nano
 vi 
 
 vi arquivolongo.txt --> (Entrar no arquivo atraves do editor)
  i --> (Dentro do arquivo com o i p/ inserir)
        (Para sair do modo de inserção aperte o esc)
        (: alguma coisa para entrar no modo de comando)		
		
 		
 :1  --> vou p/ a primeira linha do comando
 :$  --> vou p/ a ultima linha do arquivo
 :20 --> Vou p/ alinha 20 
 
 :! --> Permite eu digitar um comando no bash
			(Sai do vi digita o comando no bash e volta, ao apertar Enter, ele volta para o vi)
			
 Opções de buscas no editor vi:
 ------------------------------

 /Linux -> (vai procurar de baixo para cima a palavra Linux) 
			Ao apertar n de next vai para o próximo Linux
			Se eu quiser voltar essa busca de baixo para cima --> N
			:$ --> Vai para a ultima linha do arquivo
			?Linux --> Procura de baixo para cima

 Como recortar, copiar e colar no vi:
 ------------------------------------

 dd --> Pode ser usado p/ remover e recortar
        vai em cima da linha e digita dd (Ele recorta uma linha) 
		vai em cima da linha e digita d4d (Ele remove 4 linhas)
		vai em cima da linha e digita d6d (Ele remove 6 linhas)
		vai em cima da linha e digita d10d (Ele remove 10 linhas)
		
	Colar:
	Depois de recortado, deve escolher a linha e digitar p (A linha será colada)
	
	Outra opção de copiar e colar:
	------------------------------
	yy --> Copia a linha
	p --> Cola a linha
	
	
 Como salvar um arquivo no editor vi e sair dele:
 ------------------------------------------------
 
 :w  --> Salva o arquivo
 
 :wq --> Salvar e sair
 :x  --> Tbm salva e sai
 
 :q  --> Sair sem salvar
 :q! --> tbm sai sem salvar
 
 
 Tabela de referência:
		https://www.smashingmagazine.com/2010/05/vi-editor-linux-terminal-cheat-sheet-pdf/
		
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
16.File Globbing

 Este assunto trata-se de expressão regular:
 
 Vai ser um resumo, expressão regular é um assunto muito intenso, tem livre sobre este assunto 
 e curso que tratam só de expressão regular.
 
 Deferênça entre File Globbing e Regex
 
 Regex (Regular expression) --> P/ seleção de texto, seleciona um padrão de texto.
 
 File Globbing --> (É uma forma q o Shell tem de selecionar arquivos de diretórios aqui na 
					interface)
 
 
 Exemplos no File Globbing:
 --------------------------
 
 ls Aula* --(Qualquer arquivo q comece com Aula)
 
 ls -la Aula[12345] --> (Aqui eu informo quais os caracteres q me interessam, isso é uma lista)
 ls -la Aula[1-5]   --> (Outra forma de fazer a mesma coisa(O [] é usado para fazer uma lista)
 ls -la Aul[Aa][1-5] --> (Pode ser A ou A, vai encontrar)
 ls -la * [12] 		--> (Pega qualquer coisa q termine com 1 ou 2)
 ls -la *11 --> (Vai mostrar o seguinte: Aula11 e AULA11) Ou seja caixa alta e caixa baixa
 ls -la {Aula,AULA}11 --> (Vai trazer a mesma coisa desde d q termine com 11)
 
 
 Obs: [] os colchetes faz a lista
	  {} os chaves eu escolho as strings q me interessam
	  
 
 ls -la Aula1? --> (? Estou exigindo q tenha um caracter após o 1)
 
 Exemplos:
 
 Aula10
 Aula11
 Aula12
 Aula13... Ou seja qulaquer caracter após o 1 --> (Note q não mostra Aula1)
 
 
  ls -la Aula? --> (? Estou exigendo q tenha apenas u1 caracter)
 
 Exemplos:
 
 Aula1
 Aula2
 Aula3
 Aula4
 Aula5...
 
 
 ls -la Aula?? --> (?? Estou exigendo q tenha 2 caracter)
 
 Exemplos:
 
 Aula11
 Aula12
 Aula13
 Aula14
 Aula15...
 
 Os principais caracteres que se usa no File Globbing:
 
 *  --> Qualquer coisa ou nada
 ?  --> Quer dizer um caracter específico
 [] --> Uma lista de caracteres possíveis
 {} --> Para as strings que me interessam
 
 Continuação na próxima aula...
 					
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
17.Básico de Expressões Regulares

 # --> Comentário
 
 grep  --> global regular expression printing (impressão global de expressões regulares)
 egrep --> Extended regular expression (Expressão regular estendida)
  
 grep  --> Serve para procurar o conteúdo dentro de uma string:
 egrep --> Aceita mais expressões regulares
 
 Exemplos:
 --------
 
 egrep Linux texto.txt --> (Ou seja, onde encontrar a palavra Linux dentro do arquivo vai mostrar,
							porém, mostra a linha inteira)
							
 Comando para consultar os alias:
 -------------------------------- 
 
 alias							
 egrep --color --> (Mostra colorido o conteudo do arquivo selecionado) 
 
 egrep "[Ll]inux" text.txt --> (Estou dizendo q quero a primeira letra maiuscula ou minuscula)
 
 
 egrep "b[aei]g" texto.txt --> (Alguma coisa que comece com "b" e uma lista "aei" fechando com "g")
 egrep "b[a-o]g" texto.txt --> (Faz a mesma coisa) A lista pode ser usada com letras ou com numeros
 
 egrep "^Linux" texto.txt --> (Quero q me retorne 1 linha com uma palavra específica q esteja no 
								começo dessa linha)
								Para isso se usa ^ no começo. 
								Toda linha que tenha uma palavra que comece com Linux será exibidas
 
 egrep "^#" texto.txt --> (Tudo q começar com #) 
 egrep -v "^#" texto.txt --> (-v faz o contrario, não me mostra essa string)
								Ou seja, mostrará tudo, menos os comentários
								
 egrep "Linux$" --> (Sempre q encontra a palvra Linux no final da linha, va me mostrar)								
						Para isso serve o $
						
						
 egrep "^$" texto.txt --> (Para mostrar as linhas em branco)
 egrep -v "^$" texto.txt --> (Para não mostrar nenhuma linha em branco)
 
 
 * na expressão regular é diferente do File Globbing:
 ----------------------------------------------------
 
 * --> Indica q o caracter anterior pode aparecer nenhuma vez, ou varias vezes.
 
 Exemplo:
 --------
 
 egrep "b[a-i]g*" texto.txt --> (bag
								 beg
								 big
								 beginner
								 bigger
								 bege)
								 
 								 
								
  								
 egrep "b[a-i]g+" texto.txt --> (+ Sig. q o caracter anterior tem q aparecer pelo menos 1 
									ou mais vezes)
									
 									
 
 
 egrep "b[a-i]g?" texto.txt --> (? Sig q o caracter anterior pode aparecer nenhuma 
									ou apenas uma vez)
									
 egrep "O.Linux" texto.txt --> (. Sig. Qualquer coisa depois do ponto mais o Linux, pode ser um		
									espaço em branco, pq tbm é um caracter)									
 
 egrep "O Linux" texto.txt --> (No caso de espaço, pode usar essa sintaxe)
 
 egrep "O..Linux" texto.txt --> (Se eu quiser duas coisas deposi di Linux)
 
 egrep "O.*Linux" texto.txt --> (O.*Linux: Sig. Que entre a palavra O e Linux, pode existir qualquer coisa)
 
 
 Outra coisa interessante de ver é a proteção do ponto: Exemplo \.
 -----------------------------------------------------------------
 
 egrep "[Ll]inux." texto.txt --> (Pega a palavra Linux ou linux q tenha um ponto após essa palavra,
									porem, pega tbm espaços depois dessa palavra Linux ou linux)
									
 Quando eu quero protegar isso, ou seja, apenas o caracter ponto mesmo. 
 
 Exemplo: 									
 
 egrep "[Ll]inux\." texto.txt --> (Neste caso vai pegar a palavra Linux ou linux e q tenha . 
									apenas após a palavra)
									Em outras palavras estou dizendo p/ o Shell não interpretar 
									isso como parte da expressão regular.

 Obs: O uso da barra invertida é importante para proteger dentro da expressão regular.

 ^ --> Começar 
 
 Exemplo:
 --------
 
 sed '/^#/d' texto.txt --> (Sempre q começar com # deletar)
 
 sed 's[Ll]inux/Unix/g' texto.txt --> (Toda vez q encontrar Linux ou linux, substituir por Unix)
										g  sig. global
 
  
							
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
Questionário 1: Teste da Seção de Revisão:

 Pergunta 1:
 Qual a saída do comando abaixo:
 
	 echo 'Use a variável $SHELL para verificar o SHELL em uso'
	 
 Resposta 1:	
 -----------
		Use a variável $SHELL para verificar o SHELL em uso
 
 ----------------------------------------------------------------------------------------------- 
 
 
 Pergunta 2:
 -----------
 
 Respota 2: Apenas o usuário e o grupo possuem a permissão "w" e podem então alterar o arquivo.
		  Demais usuários do sistema podem apenas ler o arquivo.
		  
 -----------------------------------------------------------------------------------------------		  
 
 
 Pergunta 3:
 ----------- 
 Qual opção do comando cat mostra os caracteres especiais de um texto como por exemplo 
 indicadores de tabulação, final de linha e etc?
 
 Respota 3: cat -A 

 -----------------------------------------------------------------------------------------------
 
 Pergunta 4:
 -----------
 Você digita ls *e[0-9].doc em um diretório.
 Qual dos seguintes nomes de arquivo, se existente, será exibido no resultado?

 Respota 4: telefone2.doc
 
 
 ----------------------------------------------------------------------------------------------
 
 Pergunta 5:
 -----------
 Qual opção deve ser utilizado no comando "echo" para que não haja uma quebra de linha no final
 de sua execução?

 Respota 5: 
			echo -n 
 
 Para q haja uma quebra: 
			echo -e
			
 ----------------------------------------------------------------------------------------------
  
 Pergunta 6:
 -----------
 Qual comando deve ser utilizado para que apenas a primeira linha do arquivo notas.txt seja 
 exibida?
 
 Resposta 6: 
			head -n1 
			ou
			head -1
			
			
 ----------------------------------------------------------------------------------------------			
 
 Pergunta 7:
 -----------
 Qual o resultado do comando abaixo?
 # wc -l alunos*|sort -rg|grep -v|head -n1
 
 Resposta 7:
			Desntre os arquivos q começam com "alunos" no nome, exibe apenas o que possui mais		
			linhas, acompanhado do total de linhas do arquivo.
			
 ----------------------------------------------------------------------------------------------

 Pergunta 8:
 ----------- 
 Qual comando redireciona tanto a saída padrão quanto a saída de erro para o arquivo log.out?
 
 Resposta 8:
			comando > log.out2>&1
			
 ----------------------------------------------------------------------------------------------
 
 Pergunta 9:
 -----------
  Qual das afirmações abaixo é a mais correta para o comando:
  grep -E "^[0-9][A-Z]" aruivo.out
  
  Resposta 9:
			Serão retornadas todas as linhas q contenham no começo da linha um número seguido por
			uma letra maiúscula.

 ----------------------------------------------------------------------------------------------
 
 Pergunta 10:
 -----------
 Qual comando deve ser utilizado no vi para q seja possível sair sem salvar as alterações 
 realizadas?
 
 Resposta 10:
 ------------
			:q!
 
  
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
Seção 3: Criando e Executando um Shell Script

18.Primeiro Script -Nomes, Permissões e Execução 

 Criando o primeiro script no Shell Bash.
 
 Criar 
 Executar
 
 É importante usar um padrão para criar um nome. Exemplo: 
 
 vi primeiro_script.sh
 vi PrimeiroScript.sh
 vi PRIMEIRO_SCRIPT.sh
	Obs: sh é opcional, porém, é padrão.
	
 	
 Observar o padão da empresa que estou trabalhando na hora de criar meus script.

 
 Ao criar o script, a 1º coisa é informar qual vai ser o interpretador, por padão vamos usar o 
 bash.
 
 # Isso chama-se: shebang refere-se aos dois caracteres "#!", quando os mesmos são os primeiros 
	caracteres de um arquivo de texto, especificamente em um código fonte escrito em uma linguagem 
	interpretada.
	
 #!/bin/bash  --> Estou dizendo q a linguagem abaixo está utilizando a linhuagem do bash
 
 Posso colocar o interpretador q eu quiser. Exemplo:
 
 #!bin/sh
 #!bin/bash
 #!bin/ksh
 #!bin/csh
 #!bin/python
 
 
 #!/bin/bash
 clear
 echo "========== Meu Primeiro Script =========="
 echo "" 										--> Deixar uma linha com espaço em branco
 echo -n "Exibir data e hora atual: "			--> -n p/ não quebrar linha
 date
 echo "========================================="
 sort ../arquivos/alunos2.txt                    --> P/ exibir

 Cursos/CursoShellScript/arquivos/alunos2.txt
 
 esc :!ls -l ../arquivos 							 -->  Para consultar o nome do arquivo q quero exibir 									
 
 esc :wq  
 
 
 ls -l --> Exibe os detalhes dos diretórios
 
 1º Primeira coisa, verificar as permissões do meu Script
 
 -rwxr-xr-x 1 adr adr 911 set 1 2017 PrimeiroScript.sh
 
 -rwxr --> Permissões do usuário  (r pode ler/ w pode escrever) no arquivo
 -xr   --> Permissões do grupo    (o grupo pode apenas ler (r))
 -X    --> Permissões dos outros  (Podem somente ler os arquivos)  
 
 Todas as permissões são associadas a um usuário e a um grupo:
 
 adr --> Usuário
 adr --> Grupo
 
 1º coisa a se fazer é dar permissão de execução nesse arquivo.
 
 chmod +x --> Dá permissão de execução para usuário/grupo/outros (-rwxr-xr-x)
 chmod u+x --> Permissão de execução apenas p/ o usuário 
 chmod 777 PrimeiroScript.sh
							--> Permissão de leiura escrita e execução p/ todos os usuários do sistema 
								(Não é recomendado usar essa opção)
								
 chmod 744 PrimeiroScript.sh -->  Só eu tenho permissão de execução, os outros apenas leitura.								
 
 chmod +x PrimeiroScript.sh  --> Todos os usuário do sistema tem permissão de execução aqui.
 

 Existem várias formas de executar os script's:  
 ----------------------------------------------
 
 A forma mais comum de executar o Script:
 
 ./SegundoScript.sh -->  ./ é a mesma coisa de digitar o caminho inteiro do arquivo 
 
 Exemplo:
 
 /home/adr/Cursos/ShellScript/Scripts/SegundoScript.sh
 
 
 Obs: Quando eu executo um script, implicitamente abre um novo shell executa esse script em um 
      processo filho e depois retorna para o Shell atual.

 Tem uma forma de executar que ele executa no próprio Shell atual
 
 Exemplo:

 source SegundoScript.sh --> Executou no próprio bash
  Obs: O source pode ser substituído por .
     Exemplo:
	 
 . SegundoScript.sh
 
 Resumindo, as três formas de executar script no shell:
 
 
 ./SegundoScript.sh   		--> Abre um novo bash
 source SegundoScript.sh	--> No próprio bash
 . SegundoScript.sh			--> No próprio bash
 
 
 Outros exemplos é executar chamando o interpretador:
 ----------------------------------------------------
 
 sh SegunsoScript.sh
 bash SegunsoScript.sh 		
 ksh SegunsoScript.sh
 csh SegunsoScript.sh
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
19.Definições de PATH

 $PATH --> É uma variável de ambiente 
		   Essa variável é setada quando eu logo no sistema.
 

 echo $PATH --> Para verificar qual é o meu PATH atual
 
 Eu posso guardar meu diretório em uma variável de ambiente.
 Exemplo:
 
 PATH="$PATH:/home/adr/Cursos/ShellScript/Scripts"
 
 echo $PATH --> Vai mostrar tudo q eu tinha antes, mas o que eu adicionei
 
 
 
 Obs: Quando eu guardo meu arquivo em uma variável de ambiente, posso executar de qualquer lugar.
 Exemplo:
 
 É só digitar o nome do arquivo que ele executa:
 
 SegundoScript.sh 
 
 Não foi necessário encontrar o diretório e executar o camando: ./SegundoScript.sh
 
 Quando eu faço dessa forma, fica apenas na minha variável local, se eu reiniciar ou se eu fechar
 meu terminal não vai estar.
 
 Como eu faço para deixar isso definitivo?
 
 Editando o ~/.profile --> Exemplo:
 
 vi ~/.profile
 
 No dia a dia, isso ajuda bastante, colocar os scripts no PATH.
 
 Esse foi o objetivo dessa aula.
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	 
20.Comentários - Boas Práticas

 Cirar comentário é essencial para o uso futuro desse script, pra entender o que faz, como faz, 
 e como funciona cada função dele.
 
  Algumas maneiras de criar comentários no ShellScript:
  
  1º Coisa é criar um cabeçalho (É onde se informa pra que serve o script, qual a função, quem criou
								 quando foi criado, quais alterações foram feitas no decorrer do tempo)
								 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	 								 
21.Trabalhando com variáveis no Shell Script.

 
 
  
 

 
 
 
 
 
 
 
 
 
 						




 
 
 
 
 
 
 
 
 
	
	
  			
 			
 
 
 
 
  

  
 
 
 
 
 
 
								
 								
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 

















