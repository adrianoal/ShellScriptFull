---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------				
			-- Programação Shell Script - Automatizando Rotinas no Linux --
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
Prof: Ricardo Prudenciato

-----------------------
- Seção 1: Introdução -
-----------------------

1.o que é Shell Script

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
2.Como será o Curso

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
3.Antes de começarmos

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
4.Arquivos e Scripts Usados Durante o Curso


---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	


Administrador de sistemas e analista de suporte.

Para quem deseja trabalhar com Linux e Unix

Unix  --> S.O
Linux --> S.O (Linux é baseado no Unix.)
 
 
Shell --> É a interface entre o usuário e o sistema operacional (kernel)

Kernel --> O kernel é considerado o principal item dos sistemas operacionais, 
		   sendo que ele é a ligação entre o processamento de dados e os programas.
		   

Verificar se o vi está instalado: (Vi editor de testo do linux)
sudo dpkg -l |grep vim 


Se não tiver o vi Instalado, instale com o comando abaixo:
sudo apt-get install vim

Usuario: adriano
Senha: Adri@no310710


---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
Prof: Ricardo Prudenciato

-----------------------
- Seção 2:  -
-----------------------

5.O Shell

  É a interface entre o usuário e o sistema OP. Unix/Linux
  
  USUÁRIO
	SHELL --> Uma das ferramentas para acessar o Kernel é o Shell.
		KERNELL --> Administrador do Hardware
			HARDWARE --> Baixo nível, CPU, memório, HD e etc.



 TIPOS DE SHELL:
 ---------------
 
 Bourne Shell (sh): Shell original e padrão do Unix
 
 Bourne-Again Shell (bash): Shell padrão no Linux compatível com sh mas com melhorias.
							Tbm incorpora recursos so csh e Ksh.

 Korn Shell (Ksh): Tbm uma melhoria do bourne shell 

 C Shell (csh): Traz para o shel recursos da linguagem C.

 
 
 Qual o shell estou usando --> echo $0
 Outra forma de verificar --> tail /etc/passwd
 
 Verificar se outros shel estao instalado na minha maquina: --> sudo -l |grep ksh
 
 Se eu quisesse instalar --> sudo apt-get install ksh
 
 Entrar no Shell ksh --> ksh
 Verificando novamente -->  echo $0
 Para sair do shel ksh --> exit
 
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
6.Principais Comandos Linux - Parte 1

 nome do comando --help --> mostra as opções q o comando oferece ex:
 touch --help 
 man touch --> Mostra o manual mais completo
 
 
 cd arquivos --> Entrar em um diretorio 
 cd .. --> volta para o diretorio anterior
 
 cd../../ --> Volta para a raiz
 
 cd - --> volta p/ o arquivo anteiror
 
 cd  --> cd espaco vai para o home
 
 pwd --> mostra o diretorio atual
 
  
 cd ~usuario --> vai p/ o home do usuario q eu quiser
 
 ls --> listar
 
 ls -ltr --> ordena do mais velho para o mais novo
 
 ls -l --> mostra os detalhes dos diretorios
 
 
 ps --> mostra meus processos do meu usuario apenas na minha sessao
 
 ps axu --> Mostra varias informaçoes: Nome do usuario dono do processo. 
			id do processo. Consumo de CPU/Memoria. 
			Quanto tempo esta em execucao e o nome do processo.
 
 touch --> P/ criar um arquivo em branco, ou atualizar um arquivo q ja existe			
		   Para criar --> touch arquivo-teste
		   
 touch --help --> Para ver as opcoes dos comandos			


 echo --> Para mostrar na tela algum parametro q vc deu ex:
 echo Adriano estudando shell script
 echo -n Adriano estudando shell script --> -n não vai quebrar a linha
 echo -e "Curso shell\n script" -- Coloca uma quebra de linha 
 
 echo -e --> Aceita caracteres especiais ex:
  echo -e "Curso shell\script\novo desafio" 
 
 mkdir --> criar um diretorio ex:
 mkdir diretorio1
 
 Criar um diretorio dentro de um determinado diretorio:
 mkdir diretorio1/exercicio1
 
 rm xxxxx --> Comando para remover/apagar um arquivo
 
 rm -r xxxxx --> Comando para remover/apagar um diretorio
 
 rmdir xxxx --> Só funciona se o diretorio estiver vazio
 
 sleep --> Comando q conta um tempo. Ex:
 sleep 10 --> conta 10segundos e volta a linha de comando
 

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
7.Principais Comandos Linux - Parte 2

 Comandos de manipulação de arquivos:
 
  O comando cat do Linux é um dos mais úteis para se aprender. 
  Seu nome é uma derivação da palavra concatenate (concatenar) e permite que você crie, 
  e exiba arquivos no formato padrão de tela ou em outro arquivo, entre outras coisas.
 
 cat arquivos.txt --> P/ exibir o conteudo de arquivo
 cat -b alunos2.txt --> Numera as linhas q nao estão em branco
 cat -n alunos2.txt --> Numera todas as linhas, até as q estão em branco
 cat -A alunos2.txt --> Mostra caracteres especiais 
						(Ajuda a identificar os caracteres q nao aparecem)

 cat --help --> Mostra todas a opções possíveis

 tac alunos2.txt --> Lê o arquivo em ordem decrescente
 
 tail arquivilongo.txt --> Mostra as ultimas dez linhas
 tail -n5 arquivilongo.txt --> Determino quantas linhas quero exibir.
 tail -5 arquivilongo.txt --> Outra forma de fazer a mesma coisa
 
 
 
 head arquivilongo.txt --> Mostra as primeiras dez linhas do arquivo
 head -5 arquivilongo.txt --> Determino quantas linhas quero exibir.
 
 head -c10 arquivilongo.txt --> Determino a qtde de caracteres q quero exibir
 
 
 
 wc --> Conta caracteres,linhas, palavras e bytes de um arquivo.
 wc alunos.txt --> A saída mostrou qtde de linhas	
								   qtde de caracteres	
								   qtde de Bytes

 wc -l alunos.txt --> Mostrará só o número de linhas								   
 wc -m alunos.txt --> Mostrará só o número de caracteres
 wc -c alunos.txt --> Mostrará só o número de bytes
 
 wc alunos* --> Faz a contagem para todos os arquivos
 
 tail -n5 alunos2.txt |wc -w --> Está pegando a saído do arquivo alunos2.txt e 
											usando como parametro de entrada.
											
 											
 sort --> Para ordenar um arquivo
 
 sort alunos.txt --> Exibe de forma ordenada
 sort -r alunos.txt --> Ordena de forma reversa(z-a)
 sort -k2 alunos.txt --> ordena a partir do segundo campo
 sort -k3 alunos.txt --> ordena a partir do terceiro campo
 
 uniq alunos.txt --> Toda vez q um nome estiver repitido na sequencia, mostrará apenas um.
  
  Uma forma de resolver isso, é ordenar primeiro e depos exibir com o uniq. Exemplo:  
 sort alunos.txt |uniq
 
 --Primeiro ordeno depois exibe, exemplos abaixo:
 
 sort uniq -u alunos.txt --> Mostra apena os q apareceram uma vez
 sort uniq -d alunos.txt --> Mostra apena os q apareceram duplicados
 sort uniq -c alunos.txt --> Conta as repetições
 
 sort alunos.txt |uniq -c |sort --> Conta os q repitiram mais vez e ordena do maior p/ menor
 
 sort alunos.txt |uniq -c |sort -r |head -n1 --> Só a linha que tem mais repetição
 
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
8.Principais Comandos Linux - Parte 3

 
 tr --> Muda traduz e deleta caracteres(Pode ser uma linha ou um arquivo):
 
 cat alunos.txt |tr a e --> (Trocou toda letra a por e)
 
 cat alunos.txt |tr a-z A-Z --> (Trocou caixa baixa por caixa alta)
 
 cat alunos.txt |tr aei AEI --> (Toda letra aei foi trocada por AEI)
 
 cat alunos2.txt |tr ' ' '\t' --> (Trocando o espaço por tab)
 
 cat alunos2.txt |tr ' ' '\t' | cat -A --> (Consigo ver melhor os tab do arquivo acima)
 
 cat alunos2.txt |tr -d aei --> (Toda vez q aparecer as letras aei será deletado)
 
 echo "Curso Shell Script" |tr l L --> (Toda vez q encontrar um l trocará por L)
 
 echo "Curso Shellllllll Script" |tr -s 'l' --> (Vai comprimir o l) Exemplo: Shell p/ Shel
 
 tr --help --> (Mostra varias forma de usar esse comando)
 
 echo Curso Shell Script |tr [:lower:] [:upper:] --> (Transformar tudo de minusculo p/maiusculo)
 

 cut --> Comando para cortar uma string

 cat alunos2.txt |cut -c1-5  --> (Cortará do caracter 1-5 de cada linha)
 
 cat alunos2.txt |cut -c1,2,3--> (Quero cortar do caracter um, dois e cinco)
 
 cat alunos2.txt | cut -c5- --> (Quero cortar a partir do caracter 5 p/ frente)
 
 cat alunos2.txt | cut -c-5 --> (Cortar até o caracter 5)
 
 cat alunos2.txt | cut -f1 --> (f1 eu mostro apenas o campo 1)
 
 cat alunos2.txt |cut -d " " -f2- --> (Mostrar do campo 1 ao 3 separando com espaço) // d sig. delimitador
 
 tail /etc/passwd | -d":" -f1,5 --> (mostrar o campo 1 e o 5 separados por :)
 
 
 diff --> Usado para separar dois arquivos. (Sign. Diferença)
 
 diff alunos2.txt alunos3.txt --> (Exibe apenas a diferença entre os arquivos)
 diff alunos2.txt alunos3.txt | cat -A --> (A mesma coisa, porém, mostrou q tem um espaço)
 
 diff -w alunos2.txt alunos3.txt --> (Compara os dois arquivos, porém, 
										desconsidera os espaços em branco)
										
 Usando o comando "diff" para comparar diretórios:
 -------------------------------------------------
 
 diff -r arquivos arquivos-copia --> (Compara os dois arquivos)
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
9.Principais Comandos Linux - Parte 4
 
 
 Comando "grep" Serve para procurar o conteúdo dentro de uma string:
 -------------------------------------------------------------------
 
 grep Claudia alunos2.txt --> (Retornar toda vez q aparecer o nome Claudia)
 
 grep Claudia alunos* --> (Procura em todos os arquivos alunos q contenham a palavra Claudia)
 
 grep "Ricardo prudenciato" alunos*
 
 
 Quais as opções do comando "grep"?
 ----------------------------------
 
 grep -i RICARDO alunos*  --> (Tira a opção do case sensitive, ou seja independente de ser 
								caixa alta ou baixa) (-i deixa o comando mais pesado)
								
 grep -c Ana alunos2.txt --> (Vai contar quantas vezes encontrou a palavra Ana)								
 grep -c Ana alunos.txt* 
 
 grep -v Ana alunos.txt* --> (Faz ao contrario, não vai mostrar a linha q contenha essa 
								palavra)
 
 grep -r Ana* --> (Procurar todos os arquivos desse diretório com a palavra ana) 
 grep -rl Ana* --> (Só mostra os arquivos q contenham essa palavra, mas não lista) 
 
 cat alunos2.txt |grep Rafael 
 
 grep -A3 Carlos alunos2.txt --> (A sig. After, ou seja, 3 linhas depois da ocorrencia da palavra Carlos)
  //Muito usado para analisar log
  
  grep -B3 Carlos alunos2.txt --> (A sig. Before, ou seja, 3 linhas antes da ocorrencia da palavra Carlos)
  //Muito usado para analisar log
  
  
  Tem três opções: 
  grep  --> Para procurar o conteúdo dentro de uma string (Aceita expressão regular simples)
  fgrep --> Para procurar o conteúdo dentro de uma string (Não aceita expressões regulares)
  egrep --> Para procurar o conteúdo dentro de uma string (Aceita expressão regular estendidas)
    
 
 Comando "sed" faz um filtro e substituição de conteúdo:
 -------------------------------------------------------
 
 sed --help --> Para mostrar as posibilidades de comando
 
 sed '1,3 d' alunos2.txt --> (Para deletar da linha 1 a linha3) 
 sed  /Rafael/d alunos2.txt  --> (Procurando Rafael e deletando a linha inteira 
									toda vez q encontrar)
									
 cat alunos2.txt |sed 's/Paulo/Joao/'--> (P/ substituir o Paulo pelo Joao)									
 
 
 echo "Curso Linux Shell Script Linux" |sed 's/Linux/Unix'
									--> (Substituindo a primeira ocorrencia Linux por Unix)
										 Exemp: Curso Unix Shell Script Linux 								 

 echo "Curso Linux Shell Script Linux" |sed 's/Linux/Unix/g' 
										--> (Para substituir todas as ocorrencias tem q usar g)
										 Exemp: Curso Unix Shell Script Unix 
										 
    
 echo "Curso Linux Shell Script Linux" |sed 's/ //g' 
										--> (Toda vez q encontrar um espaço troco por nada)										 
										Exemp: CursoLinuxShellScriptLinux

 
 Comando "More"	exibe paginando, mostra o q tem na primeira página e vai descendo:									
 ---------------------------------------------------------------------------------
 
 more arquivolongo.txt
 
 less arquivolongo.txt --> (A mesma coisa do more, porém, tras mais possibilidades)
 
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
10.Principais Comandos Linux - Parte 5
 
 find --> Serve para procurar por diretorios,arquivos
 
 find /home  
 find /  
 find ./     --> Do meu diretorio pra frente
 
 find ./ -name alunos.txt --> Procura arquivos 
 find ./ -name alunos.txt* --> Procura arquivos 
 find ./ -name *copia*
 find ./ -user adr -name alunos2.txt
 										
 find ./ -name alunos* -exec ls -l {} \. --> (no lugar do {} sera colocado as saidas do comando)
 
 date --> (Mostra a data e hora do sistema. Sem parametros)
 date --help --> (Mostra todas as possibilidade)
 
 date +%H 	 --> (Se eu quiser mostrar só a hora?)
 date +%M 	 --> (M maiusculo para minuto)
 date +%m 	 --> (m minusculo para mês)
 date +%D 	 --> (D Mostra a data no seguinte formato: 06/23/20)
 date +%d 	 --> (m minusculo só o dia)
 date +%d/%m --> (para dia e mes)
 
 
 seq Comando para gerar uma sequencia:
 -------------------------------------
 
 seq 10   	--> (Faz uma seq de 1 a 10)
 seq 0 12 	--> (vai do 0 ao 12)
 seq 5 a2 	--> (vai do 5 ao 12)
 seq 5 2 30 --> (vai do 5 ao 30 com intervalos de dois em dois)
   // Muito usado em instruções de loop, for, while
   
 
 expr --> Comando utilizado para fazer contas:
 ---------------------------------------------
 
 expr --help --> (Para ver todas as operações possíveis)
 
 expr 5 + 2 --> (7 a sintaxe precisa de espaço)
 
 expr 5 / 2 --> (2 n mostra as casas decimais)
 
 expr 5 /* 2 --> (10 neste caso te q usar a barra para proteger, pq no shell * 
					é um caracter especial)

 					
 
 expr 5 /* 2 - 2 --> (8) 
 
 echo 3 + 2 | bc --> (bc interpleta uma string como numerico)
 
 echo "(3 + 2)*5" | bc --> (25)
 
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
11.Execução Sequencial de Comandos do Shell

 cat alunos.txt |wc -l --> (listou o arquivo/ contou numero de linhas)
 
 date; echo Linux; ls --> (Um exemplo de sequencia de comandos)
 
 ls alunos.txt && echo Linux --> (&& Sign. q se o 1º comando falhar ele nem executa o 2º.)
									Caso não queira app essa regra, deve utilizar --> ;

 									
 ls alunos.txt || echo Linux --> (|| Sign. q se o 1º comando for executado com sucesso eu não executo o 2º.
											 se o 1º der erro, eu executo o 2º)
											 
 ls -l --> (Total de arquivos e o usuario, local e etc.)										 
 
 cd .. --> (P/ ver o diretorio anterior)
 ls    --> (P/ listar o diretorio)
 
 
 Como voltar p/ o arquivo anterior e listar em um unico comando?
 
 cd ..; ls -l --> (Conforme o exemplo acima, em um unico comando, 
					voltou p/ o diretorio anterior e listou os conteudo do arquivo)
					
 ( cd ..; ls -l ) --> Colocar entre () sign q implicitamente sera aberto um novo Shell, 
						e já volta p/ o Shell atual					
						
 						
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
12.Redirecionamento de Entrada e Saída

 Todo comando recebe um entrada e gera uma saída padrão e uma saída de erro
 
 Entrada 	   --> STDIN  (0)
 Saída Padrão  --> STDOUT (1)
 Saída de Erro --> STDERR (2)
 
 As saídas tanto STDOUT e STDERR são exibidas na tela, porém, essas saídas podem ser 
 redirecionadas p/ outro arquivo, uma impressora e etc.
 
 cat alunos3.txt --> (Exibicao do conteudo do arquivo na tela) 
 
 
 Redirecionamento de arquivos:
 
 > Criar 
 >> Existente
 
 Exemplos de redirecionamento de saídas:
 ---------------------------------------

 cat alunos3.txt > alunos-temp.txt --> (> Criando um novo arquivo)
 cat alunos3.txt >> alunos-temp.txt	-->	(>> Redirecionando p/ um novo arquivo)									 
 
 cat alunos3.txt > alunos-temp.txt
 cat alunos-temp.txt
 
 date > alunos-temp.txt --> (Pegou a saída e sobrescreveu o arquivo, ou seja, apagou o q tinha)
 
 date >> alunos-temp.txt --> (Vai concatenando as saídas, e mantendo o conteudo do arquivo anterior)
 
 ls -l alunos.txt
 
 ls -l alunos.txt5 > log.out --> (esse arquivo nao existe, portanto deve ser direcionado para a 
									saida de erro STDERR (2).) Exemplo:
 									
 
 ls -l alunos.txt5 2> log.out --> (Quando o arquivo n existe precisa ser jogado para log de erro:
									STDERR (2), conforme este exemplo)
 
  
 ls -l alunos.txt5 2>> log.out --> (2>> p/ Jogar no log de erro: STDERR (2) e concatenar as saídas)
 
 
 Usando os dois comando em uma uncia instrução:

 ls -l alunos.txt5 > log.out 2> log-erro.out --> (Se der certo, joga no 1º, se der errado joga no 2º)

 ls -l alunos.txt5 >> log.out 2>&1 --> (Saída padrão vai ser a mesma q a saida de erro) 
 
 cat log.out
 cat log-erro.out
 
 As saídas dever ser jogadas para um arquivo de log, ou para lugar nenhum --> Ex. /dev/null
 /dev/null --> Serve p/ omitir uma saída de erro, q eu não quero q apareça.
 
 Um outro exemplo de redirecionamento:

cat alunos.txt |grep adr

 
 
 Exemplos de redirecionamento de entradas:
 -----------------------------------------
 
 cat alunos.txt |tr a A 
     Obs: O comando 'tr' tem q receber uma entrada
	 
 Uma outra forma de fazer a mesma coisa:
 
 tr 'a' 'A' < alunos.txt --> (Estou redirecionando a saida do arquivo com parametro de entrada 
								p/ o comando tr)

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
13.Variáveis no Shell

 O Shell trabalha com variáveis de ambientes, variáveis setadas nele.
 Essas variáveis são carregadas no momento do login, ao iniciar a sessão e fica disponível para o 
usuário e para o sistema em geral.
 
 Essas variável são possíveis verificar por dois comandos: 
 
 env --> Vê a variável q foi exportada
 set --> Vê as variáveis locai e as exportadas
 
 env |less --> ()
 set |less --> ()

 Como referenciar essa variáveis?
 --------------------------------
 
 Sempre referenciar uma variável com o sinal de $ na frente. Exemplo:
 
 echo $HOME --> (P/ ver o conteúdo da variável HOME)
 
 
 Declarando variável no Shell:
 -----------------------------
 
 Variáveis no Shell, pode começar com letras maiuscula ou minuscula e_
 
 Exemplo:
 
 Variavel1=Adriano
 echo variavel1
 
 
 Curso="Curso de Shell Script"
 echo $Curso
 
 
 echo $$ --> (Mostra o PID da sessão atual)
				//process identifier (PID) ou ID do processo
				
 ps axu |grep bash --> (Mostra os processos q estão em execução)				
 
 
 Quando a variável é declara, ela fica local. Não é acessível a outros Bash, quando acessar de novo 
essas variáveis não estarão mais disponíveis, são apenas locais desse bash.
 Como exportar a variável?
 
 Declarando variável e atribuindo valor:
 ---------------------------------------
 
 TESTE=Curso
 echo $TESTE
 
 echo $$
  // meu PID 10643
  
  
  Para abrir um bash em cima do atual é só digitar o comando abaixo:
  
  bash
  echo $$ --> (Mostra o PID da sessão)
  // meu PID da nova sessão 10811
  exit --> (P/ Sair da sessão atual e voltar p/ a anterior)
  
  
  Exportando a variável para os processos filhos desse Bash
  
  export TESTE --> (Será exposta p/ outros processos filhos desse bash)
  
  
  
  Como colocar o resultado de um comando dentro de uma variável?
  --------------------------------------------------------------
  
  date +%H --> (Hora atual do sistema)
  
  Para guardar esse valor dentro de uma variável?
  -----------------------------------------------
  
 HORA=`date +%H´ `--> ( Não é aspas, isto é uma crase. 
						Usado p/ guardar um resultado dentro da variável)
						
 Uma outra forma é (). Exemplo:

 MINUTO=$(date +%M) --> (Guardando o resultdo na variável)
 echo $MINUTO
 
 exibindo as duas variáveis:
 
 
 echo $HORA:$MINUTO
 
  
 env --> Vê a variável q foi exportada
 set --> Vê as variáveis locai e as exportadas
 
 
 Exemplo:
 
 env |grep HORA
 set |grep HORA
 
 
 export VAR1=Valor --> (Declarando e exportando ao mesmo tempo)
 env |grep VAR1 --> (Ele reconhece essa variável)
 
 
 Em resumo essas foram as variáveis de ambiente utilizadas dentro do Shell, muito utilizadas em
Script. 

---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
14.O uso das Aspas no Shell
 
 O Shell tem uma serie de caracteres especiais. 
 
 $  	--> P/ referenciar um avariável
 ' `´ ' --> P/ fazer uma execução de subcomandos
 
 Esse caracteres no momento da execução são interpretados, a primeira coisa q o Shell faz é 
interpretar os caracteres especiais.

 Tem situações que não desejamos que o Shell traduza esses caracteres.

 Usamos as aspas para proteger, fazer com q o Shell ignore esses caracteres.
 
 Exemplos:
 
 echo * --> (Isso sign. pegar todos os arquivos do diretório atual)
 echo "*" --> (Neste caso ele não interpreta o *)Isso sign. proteger o caracter com as aspas duplas
 echo '*' --> (tbm é possível proteger com aspas simples)
 echo \* --> (\ tbm protege o caracter seguinte)
 
 ls aluno*   --> (Listar toda palavra ou string que comece com a palavra aluno)
 ls "aluno*" --> (Quando eu faço isso, estou protegendo e o Shell não vai encontrar)
 
 Formar de proteger o caracter:
 ls "aluno*"
 ls 'aluno*'
 ls aluno\*
 
 As aspas duplas protegem todos os caracteres exceto --> $ ´ /
 As aspas simples protegem tudo
 
 Exemplo:
 
 echo "$TESTE" --> (O shell continua interpretando)
 echo '$TESTE' --> (Neste caso, não funciona, pq o Shell protege)
 echo \$TESTE  --> (tbm não funciona, o Shell protege)
 
---------------------------------------------------------------------------------------------------	
---------------------------------------------------------------------------------------------------	
15.O editor VI


 
 
 
 
 
 
								
 								
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 

















